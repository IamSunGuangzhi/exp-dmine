package ed.inf.discovery;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import ed.inf.discovery.auxiliary.SimpleEdge;
import ed.inf.discovery.auxiliary.SimpleNode;
import ed.inf.grape.graph.Partition;
import ed.inf.grape.util.Compute;
import ed.inf.grape.util.Dev;
import ed.inf.grape.util.KV;

public class DiscoveryTask {

	private int partitionID;

	/** step count */
	private int superstep;

	/** messages generated by this step */
	private List<Pattern> generatedMessages;
	private List<Pattern> previousGeneratedMessages;

	static Logger log = LogManager.getLogger(DiscoveryTask.class);

	public DiscoveryTask(int partitionID) {
		this.partitionID = partitionID;
		this.generatedMessages = new LinkedList<Pattern>();
		this.previousGeneratedMessages = new LinkedList<Pattern>();
	}

	public int getPartitionID() {
		return partitionID;
	}

	public void startStep(Partition partition) {

		long start = System.currentTimeMillis();

		Pattern initPattern = new Pattern(this.partitionID);

		initPattern.initialXYEdge(KV.QUERY_X_LABEL, KV.QUERY_Y_LABEL);

		partition.initWithPattern(initPattern);

		log.debug("init count using " + (System.currentTimeMillis() - start)
				+ "ms.");

		log.debug(partition.getCountInfo());
		log.debug(Dev.currentRuntimeState());

		List<Pattern> expandedPatterns = this.expand(partition, initPattern);
		log.debug("expanded " + expandedPatterns.size() + " patterns.");
		// TODO: automorphism check of the expendedPatterns.

		start = System.currentTimeMillis();
		for (Pattern p : expandedPatterns) {

			int matchRCount = partition.matchR(p);
			if (matchRCount == 0) {
				log.debug("pID = " + p.getPatternID() + ", Rc = 0, continue.");
				continue;
			}

			int matchQCount = partition.matchQ(p);
			log.debug("pID = " + p.getPatternID() + ", RMatch = " + matchRCount
					+ ", QMatch = " + matchQCount + ", p.xcandidate = "
					+ p.getXCandidates().toArray().length);

			p.setConfidence(Compute.computeConfidence(matchRCount, matchQCount,
					partition.getYCount(), partition.getNotYCount()));

			// TODO: to check whether this partition is further expandable.
			generatedMessages.add(p);
		}
		log.debug("compute confidence using "
				+ (System.currentTimeMillis() - start) + "ms.");
		log.debug(Dev.currentRuntimeState());

	}

	public void continuesStep(Partition partition, List<DownMessage> messages) {

		log.debug("hello continue.");

		// TODO: filter some pattern generated previous using down messages;
		int i = 0;
		for (Pattern baseMessage : this.previousGeneratedMessages) {
			i++;
			log.debug("current in step " + this.superstep + " expanded " + i
					+ "/" + this.previousGeneratedMessages.size());

			List<Pattern> expandedPatterns = this
					.expand(partition, baseMessage);
			log.debug("expanded " + expandedPatterns.size() + " patterns.");
			// TODO: automorphism check of the expendedPatterns.

			long start = System.currentTimeMillis();
			for (Pattern p : expandedPatterns) {

				log.debug(p.toString());

				int matchRCount = partition.matchR(p);
				if (matchRCount == 0) {
					log.debug("pID = " + p.getPatternID()
							+ ", Rc = 0, continue.");
					continue;
				}

				int matchQCount = partition.matchQ(p);
				log.debug("pID = " + p.getPatternID() + ", RMatch = "
						+ matchRCount + ", QMatch = " + matchQCount
						+ ", p.xcandidate = "
						+ p.getXCandidates().toArray().length);

				p.setConfidence(Compute.computeConfidence(matchRCount,
						matchQCount, partition.getYCount(),
						partition.getNotYCount()));

				// TODO: to check whether this partition is further expandable.
				generatedMessages.add(p);
			}
			log.debug("compute confidence using "
					+ (System.currentTimeMillis() - start) + "ms.");
			log.debug(Dev.currentRuntimeState());
		}

		log.debug("current step " + this.superstep + " finished.");
	}

	private List<Pattern> expand(Partition partition, Pattern origin) {

		// FIXME

		List<Pattern> expandedPattern = new ArrayList<Pattern>();

		int radiu = this.superstep;

		if (radiu == KV.PARAMETER_B) {
			log.info("r = " + superstep + ", expend stoped.");
			return expandedPattern;
		}
		log.info("expand on radiu r = " + superstep);

		for (SimpleNode n : origin.getQ().vertexSet()) {

			if (n.hop == radiu) {

				// only expand on radius R
				if (n.attribute == KV.PERSON_LABEL) {

					// node n is a person, expand with frequent edges.
					for (SimpleEdge edge : partition.getFreqEdge().keySet()) {

						if (edge.fnode == KV.PERSON_LABEL) {

							Pattern newPattern = new Pattern(this.partitionID,
									origin);
							newPattern.expend1Node1EdgeAsChildFromFixedNode(
									n.nodeID, edge.tnode);

							expandedPattern.add(newPattern);
						}
					}
				}

				else {
					// node n is an attribute node
					Pattern newPattern = new Pattern(this.partitionID, origin);
					newPattern.expend1Node1EdgeAsParentFromFixedNode(n.nodeID,
							KV.PERSON_LABEL);

					expandedPattern.add(newPattern);
				}
			}
		}

		return expandedPattern;

	}

	public void setSuperstep(long superstep) {
		this.superstep = (int) superstep;
	}

	public void prepareForNextCompute() {
		// TODO: reset messages
		this.previousGeneratedMessages.addAll(this.generatedMessages);
		this.generatedMessages.clear();
	}

	public List<Pattern> getMessages() {
		return this.generatedMessages;
	}
}
